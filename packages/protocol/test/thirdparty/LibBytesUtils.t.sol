// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import "../TaikoTest.sol";
import "../../contracts/thirdparty/LibBytesUtils.sol";

contract TestLibBytesUtils is TaikoTest {
    function testToBytes32() public {
        bytes32 v = 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20;
        bytes memory byteArray = new bytes(32);

        // copy the 32 bytes into the byteArray
        uint256 ptr;
        assembly {
            ptr := add(byteArray, 32)
            mstore(ptr, v)
        }

        // For i = 0 to 32, the following values are supposed to be returned.
        //
        //  0x0000000000000000000000000000000000000000000000000000000000000000
        //  0x0100000000000000000000000000000000000000000000000000000000000000
        //  0x0102000000000000000000000000000000000000000000000000000000000000
        //  0x0102030000000000000000000000000000000000000000000000000000000000
        //  0x0102030400000000000000000000000000000000000000000000000000000000
        //  0x0102030405000000000000000000000000000000000000000000000000000000
        //  0x0102030405060000000000000000000000000000000000000000000000000000
        //  0x0102030405060700000000000000000000000000000000000000000000000000
        //  0x0102030405060708000000000000000000000000000000000000000000000000
        //  0x0102030405060708090000000000000000000000000000000000000000000000
        //  0x0102030405060708090a00000000000000000000000000000000000000000000
        //  0x0102030405060708090a0b000000000000000000000000000000000000000000
        //  0x0102030405060708090a0b0c0000000000000000000000000000000000000000
        //  0x0102030405060708090a0b0c0d00000000000000000000000000000000000000
        //  0x0102030405060708090a0b0c0d0e000000000000000000000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f0000000000000000000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1000000000000000000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1011000000000000000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1011120000000000000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1011121300000000000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1011121314000000000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1011121314150000000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1011121314151600000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1011121314151617000000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1011121314151617180000000000000000
        //  0x0102030405060708090a0b0c0d0e0f1011121314151617181900000000000000
        //  0x0102030405060708090a0b0c0d0e0f101112131415161718191a000000000000
        //  0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b0000000000
        //  0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c00000000
        //  0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d000000
        //  0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e0000
        //  0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f00
        //  0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20
        for (uint256 i; i <= 32; ++i) {
            // dynamically change the array length
            assembly {
                mstore(byteArray, i)
            }
            assertEq(byteArray.length, i);

            uint256 bitsToClear = (32 - i) << 3;
            bytes32 expected = v >> bitsToClear << bitsToClear;
            assertEq(LibBytesUtils.toBytes32(byteArray), expected);
        }
    }
}
